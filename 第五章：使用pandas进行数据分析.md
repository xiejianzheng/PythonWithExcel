# 使用pandas进行数据分析

本章将向你介绍pandas，Python数据分析库，或者————我喜欢这样说————基于Python的具有超级功能的电子表格。                                        
它是如此强大，以至于我合作过的一些公司，成功使用Jupyter笔记本和pandas取代了excel。    
然而，作为本书的读者，我假设你会保留Excel，在这种情况下，panda会作为一个从电子表格中读取和写入数据  
的接口。pandas使在Excel中特别痛苦的任务，更容易、更快、和更少错误。其中一些任务包括从外部来源获取
大数据集、处理统计数据、时序数据和交互式图表。pandas的超级能力是矢量化和数据对齐。正如我们在前面
的章节已经看到的，矢量化允许你编写简洁的、基于NumPy阵列的代码。而数据对齐可以确保在处理多个结果集  
时，不会有数据不匹配。

本章涵盖了整个数据分析过程：它从数据清理和准备过程开始，然后向你展示如何通过聚合、描述性统计、
可视化从更大的数据集中获取意义。在本章的最后，我们将看到如何使用pandas导入和导出数据。但首先，
让我们先来介绍pandas的主要数据结构：数据帧DataFrame和序列Series。  

## 数据帧DataFrame和序列Series

数据帧DataFrame和序列Series是pandas中的核心数据结构。在本节，我会介绍数据帧DataFrame的主要组件：
索引index、列columns和数据data。数据帧DataFrame很像一个二维的NumPy阵列array，但他带有行标签和
列标签，并且每列可以容纳不同的数据类型。通过从数据帧DataFrame中提取单个行或列，你可以得到一个
一维的序列Series。同样的，一个序列类似一个带有标签的NumPy阵列。当你查看图5-1中数据帧的结构时，
不需要很多想象力，就可以看出数据帧DataFrame将成为你的基于Python的电子表格。


图5-1

序列Series是一个带有轴标签的一维阵列。轴Axis编号为0。
数据帧DataFrame是一个带有行列标签的二维阵列，而且它的每一列可以是不同的数据类型。


为了显示从电子表格转换到数据帧DataFrame，是多么容易，思考下面的Excel表格在图5-2，
它显示了在线课程的参与者。你将在配套仓库中找到相应的文件。

为了使Excel表格在Python中可用，先要导入pandas，然后使用它的read_excel函数，它会返回一个
数据帧DataFrame。

In [1]: import pandas as pd
In [2]: pd.read_excel("课程参与者名单.xlsx")

Out[2]:		用户id	姓名	年龄	国家	分数	大陆
	0	1001	马克	55	意大利	4.5	欧洲
	1	1000	约翰	33	美国	6.7	美洲
	2	1002	提姆	41	美国	3.9	美洲
	3	1003	珍妮	12	德国	9.0	欧洲

如果你在Jupyter笔记本中运行这个代码，数据帧DataFrame将被很好地格式化为html表格，
这使它看上去更像电子表格。我将花费第7章的整个篇幅介绍如何用pandas读写Excel文件。
因此这里只是介绍性的例子，向你展示电子表格和数据帧是什么，实际上，它们十分相似。

现在，让我们从头开始重新创建数据帧，而不必从Excel文件中读取它：创建数据帧的一种
方法是，以嵌套列表的方式提供数据，以及索引值和列标签。

In [3]: data = [["马克", 55, "意大利", 4.5, "欧洲"],
		["约翰", 33, "美国", 6.7, "美洲"],
		["提姆", 41, "美国", 3.9, "美洲"],
		["珍妮", 12, "德国", 9.0, "欧洲"]]

	df = pd.DataFrame(data=data,
			  columns=["姓名", "年龄", "国家", "分数", "大陆"],
			  index=[1001, 1000, 1002, 1003])
	df

通过调用info方法，你将会获得一些基础的信息，最重要的是数据点的个数和每一列的
数据类型：
In [4]: df.info()

如果你只对列的数据类型感兴趣，运行df.dtypes()替代。
具有字符串或混合数据类型的列，将具备对象Object数据类型。
让我们现在来更仔细地看看数据帧的索引和列。

### 索引

数据帧的行标签称为索引。如果你不想有一个有意义的索引，那么在构造pandas时，
不要提供它，pandas会自动创建一个从零开始的，整型索引。我们在从Excel文件
读取数据帧DataFrame的第一个示例中看到这一点。索引将使pandas能够更快地索引
数据，并且对很多常用操作（如：合并两个数据帧）至关重要。你可以按如下方法访问
索引对象77：

In [5]: df.index
Out[5]: Int64Index([1001, 1000, 1002, 1003], dtype='int64')

如果索引是有意义的，给索引一个名称，让我们按照excel表格，将其命名为用户ID。

In [6]: df.i 2333333333313333ndex.name = "user_id"
	df

Out[6]: 	姓名	年龄	国家	分数	大陆
	用户ID
	1001	马克	55	意大利	4.5	欧洲
	1000	约翰	33	美国	6.7	美洲
	1002	提姆	41	美国	3.9	美洲
	1003	珍妮	12	德国	9.0 	欧洲

不像数据库的主键，一个数据帧DataFrame的索引可以有重复，但在这种情况下，查找值可能比较慢。
要将一个索引转换成一个常规的列，可以用reset_index()函数；要设置新索引，用set_index()函数。
如果你不想在设置新索引时丢失现有索引，请确保现先将其重置：

In [7]: # "reset_index" 转换一个索引为一列，重置索引为缺省索引。这对应于一开始我们从Excel加载的数据帧。
	df.reset_index()

In [8]: # "set_index" 转换 “姓名”列为索引。
	df.reset_index().set_index("姓名")

Out[8]: 	用户ID	年龄	国家	分数	大陆

	姓名
	马克	1001	55	意大利	4.5	欧洲
	约翰	1000	33	美国	6.7	美洲
	提姆	1002	41	美国	3.9	美洲
	珍妮	1003	12	德国	9.0	欧洲

通过执行df.reset_index().set_index("姓名")，你使用的是方法链接：
由于reset_index()返回一个数据帧，你可以直接调用另一个数据帧方法，
而不必先写出中间结果。

**数据帧方法返回拷贝**
无论什么时候，你以“数据帧.方法名()”的形式调用数据帧上的一个方法，你
都会获得一个数据帧的副本，而原始数据帧保持不变。我们刚刚通过调用
df.reset_index()做了这个事情。如果你想修改原始的数据帧，你需要将返回
值分配回原始变量，如下所示：

	df = df.reset_index()
	
因为我们没有这样做，这意味者你的变量df还是保留着它的原始数据。下一
个示例也会调用DataFrame方法，即不会修改原始的数据帧。

为了修改索引，使用重新索引reindex方法：

In [9]: df.reindex([999, 1000, 1001, 1004])

Out[9]:		姓名	年龄	国家	分数	大陆
	用户id
	999	NaN	NaN	NaN	NaN	NaN

### 列

要取得数据帧的列信息，可以运行下列代码：

In [12]: df.columns
Out[12]: Index(['姓名', '年龄', '国家', '分数', '大陆'], dtype='对象')

如果在构造数据帧时，未提供提供任何列名，pandas会使用0开始的整数为列编号。
然而，对列来说，这几乎从来都不是一个好注意，因为列代表变量，因此很容易
命名。你可以使用与设置索引名称相同的方法来设置列头的名称：

In [13]: df.columns.name="属性"
	 df

如果你不喜欢这些列名，可以重命名他们：
In [14]: df.rename(columns={"姓名": "名字", "年龄": "年纪"})

如果想删除列，使用下面语法（这个例子向你展示如何同时删除列和索引）：

In[25]: df.drop(columns=["姓名","国家"], index=[1000, 10003])

数据帧的列和索引都由Index对象表示，因此你可以通过转换数据帧来，将列改为行，
反之亦然。

In [16]: df.T # Shortcut for df.transpose()

这里值得注意的是，我们的数据帧df依然是不变的，因为我们从没有将返回的数据帧从新分配
给原始的df变量。

如果你想将数据帧的列重排，你可以使用我们在索引上使用的reindex方法，但按所需的顺序选择列，往往会更直观：

In [17]: df.loc[:, ["大陆", "国家", "名称", "年龄", "分数"]]

最后一个例子，需要很多解释：关于loc数据选择工作原理的所有内容是下一章的主题。

## 数据操控

现实世界中的数据很难放在一个银盘上，所以在使用它之前，你需要清理它，并将它
转换成易于消化的形式。本章先介绍如何如何从一个数据帧中选择数据，如何更改
数据，如何处理丢失数据和重复数据。然后，我们将使用数据帧执行一些计算，并了解
如何如何使用文本数据。结束这部分时，我将会了解pandas何时返回视图，何时返回
副本。本节中的许多概念，都与我们上一章看到NumPy阵列相关。

#### 选择数据

让我们先从按标签和位置访问数据开始，然后再查看其它方法，包括布尔索引和使用
多索引选择数据。

##### 按标签选择数据

访问数据帧数据的最常见方法是引用其标签。使用loc属性（location的缩写），来
指定要检索的行列：

  df.loc[行选择， 列选择]
  
loc支持切片符号，因此接受使用一个冒号分别选择所有行或列。此外，你还可以
提供带标签的列表、一个单独的列名或行名。让我们看看表5-1，了解如何从示例
数据帧df中选择不同部分的一些例子。

表 5-1 按标签选择数据

选择		返回数据类型		例子

单值		标量			df.loc[1000, "国家"]
一列(1维)	序列Series		df.loc[:, "国家"]
一列(2维)	数据帧			df.loc[:, ["国家"]]
多列		数据帧			df.loc[:, ["国家", "年龄"]]
列区间		数据帧			df.loc[:, "姓名":"国家"]
一行(1维)	序列Series		df.loc[1000, :]
一行(2维)	数据帧			df.loc[[1000], :]
多行		数据帧			df.loc[[1003, 1000], :]
行区间		数据帧			df.loc[1000:1002, :]

**标签切片包含闭区间**
在标签中的切片表示法与Python和pandas中其他内容中的工作方式是不一致的：
它们包含上限值。

理解具有一列或多列数据帧和一个序列的差异对你来说很重要：即使只有一列，数据帧
也是二维的。数据帧和序列都有索引，但只有数据帧有列标题。当你选择一个列作为
序列时，列标题将成为序列的名称。许多函数或方法都能同时在序列和数据帧上工作，
但在执行数学计算是，行为会有所区别：对于数据帧，pandas会根据列的标题进行数据
对齐————本章稍后会做详细介绍。

**列选择的快捷方式**
由于列选择是一种常见操作，pandas提供了一个快捷方式。而不是：
  df.loc[:, 列选择]
你可以写：
  df[列选择]

例如：
  df["国家"]从示'''例数据帧中返回一个序列，
  df[["姓名", "国家"]]返回一个包含两列的数据帧。

#### 通过位置选择
按位置选择数据帧，与我们本章开头在NumPy阵列上做的操作相应。但是，对于数据帧，你必须使用iloc属性（integer 位置的缩写）：
  df.iloc[行选择，列选择]
使用切片时，你使用标准的半开区间。表5-2给出了我们之前在表5-1中看到的相同
案例。

图5-2 按位置选择数据

选择		返回数据类型		例子
单值		标量			df.iloc[1,2]
一列（一维）	序列			df.iloc[:, 2]
一列（二维）	数据帧			df.iloc[:, [2]]
多列		数据帧			df.iloc[:, [2, 1]]
区间列		数据帧			df.iloc[:, :3]
一行(1维)	序列			df.iloc[1, :]
一行(2维)	数据帧			df.iloc[[1], :]
多行		数据帧			df.iloc[[3,1], :]
行区间		数据帧			df.iloc[1:3], :]

按标签或位置选择数据不是访问数据帧子集的唯一方法。
另一个重要的方法是使用布尔索引。让我们看看它是如何工作的。

#### 通过布尔索引选择

布尔索引是指在只由True或False组成的序列或数据帧的帮助下，选择数据帧子集。
布尔序列用于选择特定的行和列，而布尔数据帧用于在整个数据帧中选择特定的值。

最常见的是，你会用布尔索引来过滤数据帧的行。可以将其视为Excel的AutoFilter
自动过滤功能。例如，这是你如何你的数据帧，使它仅返回居住在美国且年龄超过40岁的人。

In [24]: tf = (df["年龄"] > 40) & (df["国家"] == "美国")
	 tf # 这个返回的是一个只有真/假值的序列。
	
Out[24]: user_id
	 1001	False
	 1000	False
	 1002	True
	 1003	False
	 dtype: bool 

In [25]: df.loc[tf, :]
Out[25]: 属性		姓名	年龄	国家	分数	大陆
	 用户ID
	 1002		提姆	41	美国	3.9	美洲

这里有两件事是我需要在这里说明的。第一件事是，由于技术上的限制，你不能将第3章中的
Python布尔运算符应用于数据帧上，相反，你需要使用如表5-3所示的符号。

表5-3。布尔操作符

Python基础数据类型	数据帧和序列

and			&

or			|

not			！

第二，如果你有多个条件，请确保把每一个布尔表达式放在括号之间。
这样运算符优先级就不会妨碍你。例如：& 的优先级要高于==。 
因此，如果没有括号，上面例子的表达式就会被解析为下面这样：
	df["年龄"] > (40 & df["国家"]) == "USA"

如果你希望过滤索引，你可以引用df.index：

In[26]:	df.loc[df.index > 1001, :]

对于你在Python基础数据结构中使用的in操作符，你在序列Series中需要使用isin。

以下向你展示如何过滤你的数据帧以获得意大利和德国参与者。

In[27]: df.loc[df["国家"].isin(["意大利", "德国"]), :]

当你使用loc来提供一个布尔序列时，DataFrame提供了一个特殊的语法用来选择值，在给定完整布尔数据帧的情况下。

df[布尔数据帧]

这是非常有帮助的，如果你有数据帧，仅由数字组成。
提供一个布尔数据帧，会返回一个在布尔数据帧值为False的位置上具有NaN（Not a Number）值的数据帧。

同样，关于NaN的更明细的讨论会放在稍后。

让我们来创建一个叫rainfall的仅由数值构成的数据帧。
rainfall是降雨量的意思。

In [28]: # 这可能是以毫米millimeters为单位的年度降雨量。
	rainfall = pd.DataFrame(data={
		"城市1": [300.1, 100.2],
		"城市2": [400.3, 300.4],
		"城市3": [1000.5, 1100.6]})
	rainfall

Out[28]: 	城市1	城市2	城市3
	0	300.1	400.3	1000.3
	1	100.2	300.4	1100.6

In [29]: rainfall < 400
	#返回的是一个布尔数据帧


Out[29]: rainfall[rainfall < 400]
	#这里rainfall < 400, 这个"< 400" 运算会应用到数据帧的每一个元素上。
	元素与400的比较结果会填写到返回的数据帧的对应位置中。
	
	返回的结果帧，将具有原数据帧相同的行列标签。

	railfall[rainfall < 400]
	中括号有这个索引的意思，
	我们将中括号前的数据帧称为操作目标数据帧。
	在中括号提供一个和目标数据帧大小相同的布尔数据帧，
	就是指示目标数据帧根据布尔数据帧进行相同位置的元素筛选。

注意，在这个例子中，我用来一个字典来构造了一个新的数据帧。
如果数据已经是以这种形式存在的，这通常是方便快捷的方式。
以这种方式使用布尔值，通常是用来过滤特定的值，例如异常值。

作为本章都收尾，我将介绍一种特殊的索引类型叫做多索引。

#### 使用多重索引进行选择
一个多重索引是多级别索引。它允许按层次组装你的数据，并使你很轻松访问
数据子集。例如，如果你设置数据帧的索引为大陆和国家的子集，你可以很轻
松地选择具有具有特定大陆的所有行：

In [31]:# 多重索引需要进行排序
	df_multi = df.reset_index().set_index(["大陆", "国家"])
	df_multi = df_multi.sort_index()
	df_multi
	# 这样子处理下来，大陆和国家这列会变成索引列来展示。
	# 原来的索引会变成普通列。
	# 展示的结果集还会进行分组，相同层次下的记录只会有第一条
	# 记录展示父节点的索引值，其它都会省略。

Out[31]:属性		用户id	姓名	年龄	分数
	大陆	国家	
 	美洲	美国	1000	约翰	33	6.7
		美国	1002	提姆	41	3.9
	欧洲	德国	1003	珍妮	12	9.0
		意大利	1001	马克	55	4.5

In [32]:df_multi.loc["欧洲", :]

Out[32]:属性	用户id	姓名	年龄	分数
	国家
	德国	1003	珍妮	12	9.0
	意大利	1001	马克	55	4.5

注意，pandas通过不重复最左边的索引级别(大陆)来美化多索引输出。
相反，它只在大陆发生变化时打印。

使用元组在多索引级别上进行选择： 
In [33]: df_multi.loc[("欧洲", "意大利"), :]
Out[33]: 属性		用户id	姓名	年龄	分数
	 大陆	国家
	 欧洲	意大利	1001	马克	55	4.5
	
数据帧的reset_index有个很有意思的特性，就是它会将被重置掉的
索引转换成列在数据帧中保存。如果没有调用reset_index就执行set_index
原来的索引数据将会在执行完set_index后丢失。

如果想要有选择地重置一个多索引的一部分，请提供级别作为参数。
零是最左侧的第一列：

In [34]: df_multi.reset_index(level=0)
Out[34]: 属性	大陆	用户id	姓名	年龄	分数
	 国家
	 美国	美洲	1000	约翰	33	6.7
	 美国	美洲	1002	提姆	41	3.9
	 德国	欧洲	1003	珍妮	12	9.0
	 意大利	欧洲	1001	马克	55	4.5
	 
虽然在本书中，我们不会手动创建多索引，但有一些操作，像groupby，
会导致数据帧返回一个带索引的数据帧，因此最好知道他是什么。
我们将在本章后面与groupby会面。

既然你已经了解了选择数据的各种方式，现在就可以学习如何改变数据。

### 设置数据

更改数据帧数据的最简单方式是使用loc和iloc属性为特定的元素赋值。
在我们转向处理数据帧的其他方式前，这是本节起始点：替换值和添加列。

#### 通过标签和位置设置数据
正如在本章先前指出的，当你调用数据帧方法（如df.reset_index()）时，
该方法将始终应用于副，而原数据帧将维持不变。

但是，通过loc和iloc属性赋值会改变原始数据帧。
因为我想保留我们原始的数据帧不变，所以，我正在使用一个我称为df2的
副本。如果你要改变单个值，做以下操作：

In [35]: # 首先复制数据帧，使原始数据帧保持不变
	 df2 = df.copy()
	
In [36]: df2.loc[1000, "姓名"] = "JOHN"
	 df2
	 
Out[36]: 属性	姓名	年龄	国家	分数	大陆
	 用户ID
	 1001	马克	55	意大利	4.5	欧洲
	 1000	JOHN	33	美国	6.5	美洲
 	 1002	提姆	41	美国	3.9	美洲
	 1003	珍妮	12	德国	9.0	欧洲

也可以同时改变多个值。更改ID为1000和1001的用户分数的一种方法是使用
列表：

In [37]: df2.loc[[1000, 1001], "分数"] = [3, 4]
	 df2
	# 执行完这个你会发现数据帧的索引值为1000和1001的值发生了改变
	  索引值为1000的行的“分数”列的值更改成了3。
	  索引值为1001的行的“分数”列的值更改成了4。

通过iloc按位置更改数据的方式相同。现在让我们继续了解如何使用布尔索引
更改数据。

### 通过布尔索引设置数据

用来过滤行的布尔索引也可以用来在数据帧中赋值。设想以下你需要匿名说出20
岁以下或来自美国的人的匿名：

In [38]: tf=(df2["年龄"] < 20) | (df2["国家"] == "美国")
	 df.loc[tf, "姓名"] = "xxx"
	 df2

你会看到df2中年龄小于20或国家等于美国的行的姓名列的值都被更改为了xxx。

有些时候，你有一个数据集，需要全面替换其中的某些值。即，不特定于某些列。
在这种情况下，再次使用特殊语法，并为整个数据帧提供如下布尔值（示例还是
使用rainfall 数据帧）：

In [39]: rainfall2 = rainfall.copy()

In [40]: rainfall2[rainfall2 < 400] = 0
	 # 这个就是特殊语法了，以一个布尔数据帧作为索引，进行赋值。

如果你只是想用一个值替换另一个值，那么有更简单的方法。

#### 通过替换值来设置数据

如果你要在整个数据帧或选定的列中替换某个值，可以用replace方法。

In [41]: df2.replace("美国", "U.S.")
	# 执行完这个方法后，你会发现数据帧中所有值为“美国”的值都被替换成"U.S."了。
	# 这是是全数据帧替换的语法。

反之，如果你只是想在“国家”列上操作，你可以使用以下语法：

	df2.replace({"国家": {"美国": "U.S."}})
	#这个replace的语法结构有点意识个

在这种情况下，因为“美国”只出现在国家列中，因此它产生相同的结果与前一个例子一样。
在结束本章前，让我们看看如何往数据帧中添加列。
	
#### 通过添加列来设置数据

要向表中添加新列，直接向新列名赋值就好了。
例如，你可以使用标量或数组来向数据帧添加一个新列。

In [42]: df2.loc[:, "折扣"] = 0
	 df2.loc[:, "price"] = [49.9, 49.9, 99.9, 99.9]
	 df2
	 # 如果采用列表形式的列赋值，列表的长度必须与行数相同。
	 # 这里有个很好玩的事情。
