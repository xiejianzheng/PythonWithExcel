# 使用pandas进行数据分析

本章将向你介绍pandas，Python数据分析库，或者————我喜欢这样说————基于Python的具有超级功能的电子表格。                                        
它是如此强大，以至于我合作过的一些公司，成功使用Jupyter笔记本和pandas取代了excel。    
然而，作为本书的读者，我假设你会保留Excel，在这种情况下，panda会作为一个从电子表格中读取和写入数据  
的接口。pandas使在Excel中特别痛苦的任务，更容易、更快、和更少错误。其中一些任务包括从外部来源获取
大数据集、处理统计数据、时序数据和交互式图表。pandas的超级能力是矢量化和数据对齐。正如我们在前面
的章节已经看到的，矢量化允许你编写简洁的、基于NumPy阵列的代码。而数据对齐可以确保在处理多个结果集  
时，不会有数据不匹配。

本章涵盖了整个数据分析过程：它从数据清理和准备过程开始，然后向你展示如何通过聚合、描述性统计、
可视化从更大的数据集中获取意义。在本章的最后，我们将看到如何使用pandas导入和导出数据。但首先，
让我们先来介绍pandas的主要数据结构：数据帧DataFrame和序列Series。  

## 数据帧DataFrame和序列Series

数据帧DataFrame和序列Series是pandas中的核心数据结构。在本节，我会介绍数据帧DataFrame的主要组件：
索引index、列columns和数据data。数据帧DataFrame很像一个二维的NumPy阵列array，但他带有行标签和
列标签，并且每列可以容纳不同的数据类型。通过从数据帧DataFrame中提取单个行或列，你可以得到一个
一维的序列Series。同样的，一个序列类似一个带有标签的NumPy阵列。当你查看图5-1中数据帧的结构时，
不需要很多想象力，就可以看出数据帧DataFrame将成为你的基于Python的电子表格。


图5-1

序列Series是一个带有轴标签的一维阵列。轴Axis编号为0。
数据帧DataFrame是一个带有行列标签的二维阵列，而且它的每一列可以是不同的数据类型。


为了显示从电子表格转换到数据帧DataFrame，是多么容易，思考下面的Excel表格在图5-2，
它显示了在线课程的参与者。你将在配套仓库中找到相应的文件。

为了使Excel表格在Python中可用，先要导入pandas，然后使用它的read_excel函数，它会返回一个
数据帧DataFrame。

In [1]: import pandas as pd
In [2]: pd.read_excel("课程参与者名单.xlsx")

Out[2]:		用户id	姓名	年龄	国家	分数	大陆
	0	1001	马克	55	意大利	4.5	欧洲
	1	1000	约翰	33	美国	6.7	美洲
	2	1002	提姆	41	美国	3.9	美洲
	3	1003	珍妮	12	德国	9.0	欧洲

如果你在Jupyter笔记本中运行这个代码，数据帧DataFrame将被很好地格式化为html表格，
这使它看上去更像电子表格。我将花费第7章的整个篇幅介绍如何用pandas读写Excel文件。
因此这里只是介绍性的例子，向你展示电子表格和数据帧是什么，实际上，它们十分相似。

现在，让我们从头开始重新创建数据帧，而不必从Excel文件中读取它：创建数据帧的一种
方法是，以嵌套列表的方式提供数据，以及索引值和列标签。

In [3]: data = [["马克", 55, "意大利", 4.5, "欧洲"],
		["约翰", 33, "美国", 6.7, "美洲"],
		["提姆", 41, "美国", 3.9, "美洲"],
		["珍妮", 12, "德国", 9.0, "欧洲"]]

	df = pd.DataFrame(data=data,
			  columns=["姓名", "年龄", "国家", "分数", "大陆"],
			  index=[1001, 1000, 1002, 1003])
	df

通过调用info方法，你将会获得一些基础的信息，最重要的是数据点的个数和每一列的
数据类型：
In [4]: df.info()

如果你只对列的数据类型感兴趣，运行df.dtypes()替代。
具有字符串或混合数据类型的列，将具备对象Object数据类型。
让我们现在来更仔细地看看数据帧的索引和列。

### 索引

数据帧的行标签称为索引。如果你不想有一个有意义的索引，那么在构造pandas时，
不要提供它，pandas会自动创建一个从零开始的，整型索引。我们在从Excel文件
读取数据帧DataFrame的第一个示例中看到这一点。索引将使pandas能够更快地索引
数据，并且对很多常用操作（如：合并两个数据帧）至关重要。你可以按如下方法访问
索引对象77：

In [5]: df.index
Out[5]: Int64Index([1001, 1000, 1002, 1003], dtype='int64')

如果索引是有意义的，给索引一个名称，让我们按照excel表格，将其命名为用户ID。

In [6]: df.i 2333333333313333ndex.name = "user_id"
	df

Out[6]: 	姓名	年龄	国家	分数	大陆
	用户ID
	1001	马克	55	意大利	4.5	欧洲
	1000	约翰	33	美国	6.7	美洲
	1002	提姆	41	美国	3.9	美洲
	1003	珍妮	12	德国	9.0 	欧洲

不像数据库的主键，一个数据帧DataFrame的索引可以有重复，但在这种情况下，查找值可能比较慢。
要将一个索引转换成一个常规的列，可以用reset_index()函数；要设置新索引，用set_index()函数。
如果你不想在设置新索引时丢失现有索引，请确保现先将其重置：

In [7]: # "reset_index" 转换一个索引为一列，重置索引为缺省索引。这对应于一开始我们从Excel加载的数据帧。
	df.reset_index()

In [8]: # "set_index" 转换 “姓名”列为索引。
	df.reset_index().set_index("姓名")

Out[8]: 	用户ID	年龄	国家	分数	大陆

	姓名
	马克	1001	55	意大利	4.5	欧洲
	约翰	1000	33	美国	6.7	美洲
	提姆	1002	41	美国	3.9	美洲
	珍妮	1003	12	德国	9.0	欧洲

通过执行df.reset_index().set_index("姓名")，你使用的是方法链接：
由于reset_index()返回一个数据帧，你可以直接调用另一个数据帧方法，
而不必先写出中间结果。

**数据帧方法返回拷贝**
无论什么时候，你以“数据帧.方法名()”的形式调用数据帧上的一个方法，你
都会获得一个数据帧的副本，而原始数据帧保持不变。我们刚刚通过调用
df.reset_index()做了这个事情。如果你想修改原始的数据帧，你需要将返回
值分配回原始变量，如下所示：

	df = df.reset_index()
	
因为我们没有这样做，这意味者你的变量df还是保留着它的原始数据。下一
个示例也会调用DataFrame方法，即不会修改原始的数据帧。

为了修改索引，使用重新索引reindex方法：

In [9]: df.reindex([999, 1000, 1001, 1004])

Out[9]:		姓名	年龄	国家	分数	大陆
	用户id
	999	NaN	NaN	NaN	NaN	NaN

### 列

要取得数据帧的列信息，可以运行下列代码：

In [12]: df.columns
Out[12]: Index(['姓名', '年龄', '国家', '分数', '大陆'], dtype='对象')

如果在构造数据帧时，未提供提供任何列名，pandas会使用0开始的整数为列编号。
然而，对列来说，这几乎从来都不是一个好注意，因为列代表变量，因此很容易
命名。你可以使用与设置索引名称相同的方法来设置列头的名称：

In [13]: df.columns.name="属性"
	 df

如果你不喜欢这些列名，可以重命名他们：
In [14]: df.rename(columns={"姓名": "名字", "年龄": "年纪"})

如果想删除列，使用下面语法（这个例子向你展示如何同时删除列和索引）：

In[25]: df.drop(columns=["姓名","国家"], index=[1000, 10003])

数据帧的列和索引都由Index对象表示，因此你可以通过转换数据帧来，将列改为行，
反之亦然。

In [16]: df.T # Shortcut for df.transpose()

这里值得注意的是，我们的数据帧df依然是不变的，因为我们从没有将返回的数据帧从新分配
给原始的df变量。

如果你想将数据帧的列重排，你可以使用我们在索引上使用的reindex方法，但按所需的顺序选择列，往往会更直观：

In [17]: df.loc[:, ["大陆", "国家", "名称", "年龄", "分数"]]

最后一个例子，需要很多解释：关于loc数据选择工作原理的所有内容是下一章的主题。

## 数据操控

现实世界中的数据很难放在一个银盘上，所以在使用它之前，你需要清理它，并将它
转换成易于消化的形式。本章先介绍如何如何从一个数据帧中选择数据，如何更改
数据，如何处理丢失数据和重复数据。然后，我们将使用数据帧执行一些计算，并了解
如何如何使用文本数据。结束这部分时，我将会了解pandas何时返回视图，何时返回
副本。本节中的许多概念，都与我们上一章看到NumPy阵列相关。

#### 选择数据

让我们先从按标签和位置访问数据开始，然后再查看其它方法，包括布尔索引和使用
多索引选择数据。

##### 按标签选择数据

访问数据帧数据的最常见方法是引用其标签。使用loc属性（location的缩写），来
指定要检索的行列：

  df.loc[行选择， 列选择]
  
loc支持切片符号，因此接受使用一个冒号分别选择所有行或列。此外，你还可以
提供带标签的列表、一个单独的列名或行名。让我们看看表5-1，了解如何从示例
数据帧df中选择不同部分的一些例子。

表 5-1 按标签选择数据

选择		返回数据类型		例子

单值		标量			df.loc[1000, "国家"]
一列(1维)	序列Series		df.loc[:, "国家"]
一列(2维)	数据帧			df.loc[:, ["国家"]]
多列		数据帧			df.loc[:, ["国家", "年龄"]]
列区间		数据帧			df.loc[:, "姓名":"国家"]
一行(1维)	序列Series		df.loc[1000, :]
一行(2维)	数据帧			df.loc[[1000], :]
多行		数据帧			df.loc[[1003, 1000], :]
行区间		数据帧			df.loc[1000:1002, :]

**标签切片包含闭区间**
在标签中的切片表示法与Python和pandas中其他内容中的工作方式是不一致的：
它们包含上限值。

理解具有一列或多列数据帧和一个序列的差异对你来说很重要：即使只有一列，数据帧
也是二维的。数据帧和序列都有索引，但只有数据帧有列标题。当你选择一个列作为
序列时，列标题将成为序列的名称。许多函数或方法都能同时在序列和数据帧上工作，
但在执行数学计算是，行为会有所区别：对于数据帧，pandas会根据列的标题进行数据
对齐————本章稍后会做详细介绍。

**列选择的快捷方式**
由于列选择是一种常见操作，pandas提供了一个快捷方式。而不是：
  df.loc[:, 列选择]
你可以写：
  df[列选择]

例如：
  df["国家"]从示'''例数据帧中返回一个序列，
  df[["姓名", "国家"]]返回一个包含两列的数据帧。

#### 通过位置选择
按位置选择数据帧，与我们本章开头在NumPy阵列上做的操作相应。但是，对于数据帧，你必须使用iloc属性（integer 位置的缩写）：
  df.iloc[行选择，列选择]
使用切片时，你使用标准的半开区间。表5-2给出了我们之前在表5-1中看到的相同
案例。

图5-2 按位置选择数据

选择		返回数据类型		例子
单值		标量			df.iloc[1,2]
一列（一维）	序列			df.iloc[:, 2]
一列（二维）	数据帧			df.iloc[:, [2]]
多列		数据帧			df.iloc[:, [2, 1]]
区间列		数据帧			df.iloc[:, :3]
一行(1维)	序列			df.iloc[1, :]
一行(2维)	数据帧			df.iloc[[1], :]
多行		数据帧			df.iloc[[3,1], :]
行区间		数据帧			df.iloc[1:3], :]

按标签或位置选择数据不是访问数据帧子集的唯一方法。
另一个重要的方法是使用布尔索引。让我们看看它是如何工作的。

布尔索引是指在只由True或False组成的序列或数据帧的帮助下，选择数据帧子集。
布尔序列用于选择特定的行和列，而布尔数据帧用于在整个数据帧中选择特定的值。

最常见的是，你会用布尔索引来过滤数据帧的行。可以将其视为Excel的AutoFilter
自动过滤功能。例如，
	
